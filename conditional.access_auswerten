#ca.log.ausgeben.ps1
#use Powershell 7
#unblock-File .\ca.log.ausgeben.ps1

<# 
.SYNOPSIS
  Wertet Entra ID Sign-In-Logs für Conditional Access Policies aus:
  - Report-Only: Anmeldungen, die *blockiert worden wären* (reportOnlyFailure)
  - Aktiv: Anmeldungen, die *tatsächlich geblockt wurden* (result=failure)

.BENÖTIGT
  Microsoft.Graph PowerShell (nur Teilmodule):
    - Microsoft.Graph.Authentication
    - Microsoft.Graph.Identity.SignIns
    - Microsoft.Graph.Reports
  Berechtigungen beim Connect-MgGraph:
    AuditLog.Read.All, Policy.Read.All

.HINWEIS
  - Keine automatische Modul-Installation. Bei fehlenden Modulen werden
    Installationsbefehle für den Systemkontext ausgegeben.
  - Nur benötigte Cmdlets werden importiert, MaximumFunctionCount wird erhöht.
#>

# --- robuste Voreinstellungen ---
$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'

# --- Vorsorglich MaximumFunctionCount erhöhen ---
try {
    if ($MaximumFunctionCount -lt 8192) {
        Write-Host "Erhöhe `\$MaximumFunctionCount von $MaximumFunctionCount auf 8192 ..." -ForegroundColor Yellow
        $script:MaximumFunctionCount = 8192
    }
} catch { }

# --- Benötigte Graph-Module definieren ---
$RequiredModules = @(
    'Microsoft.Graph.Authentication',
    'Microsoft.Graph.Identity.SignIns',
    'Microsoft.Graph.Reports'
)

# --- Prüfen, ob Module vorhanden sind ---
$Missing = @()
foreach ($m in $RequiredModules) {
    if (-not (Get-Module -ListAvailable -Name $m)) {
        $Missing += $m
    }
}

if ($Missing.Count -gt 0) {
    Write-Host "`nEs fehlen erforderliche Module:" -ForegroundColor Red
    $Missing | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }

    Write-Host "`nInstalliere die fehlenden Module im *Systemkontext* (als Administrator):" -ForegroundColor Yellow
    foreach ($m in $Missing) {
        Write-Host "  Install-Module $m -Scope AllUsers -Force" -ForegroundColor Yellow
    }
    Write-Host "`nAlternativ das Metapaket:" -ForegroundColor DarkYellow
    Write-Host "  Install-Module Microsoft.Graph -Scope AllUsers -Force" -ForegroundColor DarkYellow
    return
}

# --- Nur die benötigten Module importieren ---
foreach ($m in $RequiredModules) {
    if (-not (Get-Module -Name $m)) {
        Import-Module $m -ErrorAction Stop
    }
}

function Connect-GraphSafe {
    $scopes = @('AuditLog.Read.All','Policy.Read.All')
    try {
        if (Get-Command Connect-MgGraph -ErrorAction SilentlyContinue) {
            Connect-MgGraph -Scopes $scopes -NoWelcome:$true
        } else {
            Connect-MgGraph -Scopes $scopes
        }
    } catch {
        throw "Connect-MgGraph fehlgeschlagen: $($_.Exception.Message)"
    }
}

function Prompt-Mode {
    Write-Host ""
    Write-Host "Auswertungsmodus wählen:" -ForegroundColor Cyan
    Write-Host "  [1] Report-Only Policies (würden blockieren)"
    Write-Host "  [2] Aktive Policies (tatsächlich geblockt)"
    do {
        $mode = Read-Host "Bitte 1 oder 2 eingeben"
        switch ($mode) {
            '1' { return 'ReportOnly' }
            '2' { return 'Active' }
            default { Write-Host "Ungültige Eingabe. Bitte 1 oder 2." -ForegroundColor Yellow }
        }
    } while ($true)
}

function Prompt-DaysBack {
    do {
        $days = Read-Host "Wie viele Tage zurück sollen die Sign-In-Logs ausgewertet werden? (z. B. 7)"
        if ([int]::TryParse($days, [ref]([int]$null)) -and [int]$days -ge 0) { return [int]$days }
        Write-Host "Bitte eine nichtnegative ganze Zahl eingeben." -ForegroundColor Yellow
    } while ($true)
}

function Get-PoliciesByState([string]$stateValue) {
    # state: 'enabled' (aktiv), 'enabledForReportingButNotEnforced' (report-only), 'disabled'
    $policies = Get-MgIdentityConditionalAccessPolicy -All |
        Where-Object { $_.State -eq $stateValue } |
        Sort-Object DisplayName
    return $policies
}

function Prompt-SelectPolicies($policies) {
    if (-not $policies -or $policies.Count -eq 0) {
        Write-Host "Keine Policies in diesem Zustand gefunden." -ForegroundColor Yellow
        return @()
    }

    Write-Host "`nGefundene Policies:" -ForegroundColor Cyan
    for ($i=0; $i -lt $policies.Count; $i++) {
        Write-Host ("  [{0}] {1}" -f $i, $policies[$i].DisplayName)
    }

    do {
        $sel = Read-Host "Index/Indizes der auszuwertenden Policy/Policies (z. B. 0 oder 0,2,3)"
        if ([string]::IsNullOrWhiteSpace($sel)) {
            Write-Host "Bitte mindestens eine Policy auswählen." -ForegroundColor Yellow
            continue
        }
        $idx = $sel -split '[,; ]+' | Where-Object { $_ -match '^\d+$' } | ForEach-Object {[int]$_}
        $idx = $idx | Where-Object { $_ -ge 0 -and $_ -lt $policies.Count } | Select-Object -Unique
        if ($idx.Count -gt 0) { return $policies[$idx] }
        Write-Host "Auswahl ungültig. Bitte erneut versuchen." -ForegroundColor Yellow
    } while ($true)
}

function Would-Be-Blocked($appliedPolicy) {
    <#
      Report-Only: zählt als "würde blockieren", wenn:
        - appliedPolicy.result enthält 'reportOnlyFailure' (oder 'reportOnly' + 'failure')
        - Fallback: reportOnly=$true und result='failure'
    #>
    if ($null -eq $appliedPolicy) { return $false }

    $res = [string]$appliedPolicy.result
    $reportOnlyFlag = $appliedPolicy.PSObject.Properties.Name -contains 'reportOnly' -and $appliedPolicy.reportOnly

    if ($res -match '(?i)reportonly.*failure') { return $true }
    if ($reportOnlyFlag -and $res -match '^(?i)failure$') { return $true }

    return $false
}

function Was-Blocked-ByPolicy($signIn, $appliedPolicy, [string[]]$policyNames) {
    <#
      Aktiv: zählt als "tatsächlich geblockt", wenn:
        - signIn.conditionalAccessStatus = 'failure'  UND
        - appliedPolicy.displayName in Auswahl  UND
        - appliedPolicy.result = 'failure'
      (unabhängig davon, ob Grant=Block oder Grant=Grant mit nicht erfüllten Controls)
    #>
    if ($null -eq $signIn -or $null -eq $appliedPolicy) { return $false }
    if ($signIn.conditionalAccessStatus -ne 'failure') { return $false }
    if ($appliedPolicy.displayName -notin $policyNames) { return $false }
    if ([string]$appliedPolicy.result -match '^(?i)failure$') { return $true }
    return $false
}

function Get-ReportOnlyBlockedSignIns([DateTime]$sinceUtc, [string[]]$policyNames) {
    Write-Host "`nLese Sign-In-Logs (Report-Only) seit $($sinceUtc.ToString('u')) UTC ..." -ForegroundColor Cyan

    $props = @(
        'id','createdDateTime','userPrincipalName','ipAddress','appDisplayName',
        'clientAppUsed','conditionalAccessStatus','appliedConditionalAccessPolicies'
    )
    $filter = "createdDateTime ge {0}" -f $sinceUtc.ToString("o")

    $signIns = Get-MgAuditLogSignIn -Filter $filter -All -Property $props
    if (-not $signIns) { return @() }

    $hits = foreach ($s in $signIns) {
        $caps = @($s.appliedConditionalAccessPolicies)
        if (-not $caps -or $caps.Count -eq 0) { continue }

        # nur die interessierenden Policies (per DisplayName)
        $caps = $caps | Where-Object { $_.displayName -in $policyNames }
        if ($caps.Count -eq 0) { continue }

        foreach ($cap in $caps) {
            if (Would-Be-Blocked $cap) {
                [PSCustomObject]@{
                    Mode                      = 'Report-Only (würde blockieren)'
                    When                      = [datetime]$s.createdDateTime
                    User                      = $s.userPrincipalName
                    App                       = $s.appDisplayName
                    IP                        = $s.ipAddress
                    ClientApp                 = $s.clientAppUsed
                    Policy                    = $cap.displayName
                    GrantControls             = ($cap.enforcedGrantControls -join ',')
                    Result                    = $cap.result
                    ConditionsNotSatisfied    = if ($cap.PSObject.Properties.Name -contains 'conditionsNotSatisfied') { ($cap.conditionsNotSatisfied -join ',') } else { $null }
                }
            }
        }
    }

    $hits | Sort-Object When
}

function Get-ActiveBlockedSignIns([DateTime]$sinceUtc, [string[]]$policyNames) {
    Write-Host "`nLese Sign-In-Logs (Aktive Policies) seit $($sinceUtc.ToString('u')) UTC ..." -ForegroundColor Cyan

    $props = @(
        'id','createdDateTime','userPrincipalName','ipAddress','appDisplayName',
        'clientAppUsed','conditionalAccessStatus','appliedConditionalAccessPolicies'
    )
    $filter = "createdDateTime ge {0}" -f $sinceUtc.ToString("o")

    $signIns = Get-MgAuditLogSignIn -Filter $filter -All -Property $props
    if (-not $signIns) { return @() }

    $hits = foreach ($s in $signIns) {
        if ($s.conditionalAccessStatus -ne 'failure') { continue }

        $caps = @($s.appliedConditionalAccessPolicies)
        if (-not $caps -or $caps.Count -eq 0) { continue }

        foreach ($cap in $caps) {
            if (Was-Blocked-ByPolicy -signIn $s -appliedPolicy $cap -policyNames $policyNames) {
                [PSCustomObject]@{
                    Mode                      = 'Aktiv (tatsächlich geblockt)'
                    When                      = [datetime]$s.createdDateTime
                    User                      = $s.userPrincipalName
                    App                       = $s.appDisplayName
                    IP                        = $s.ipAddress
                    ClientApp                 = $s.clientAppUsed
                    Policy                    = $cap.displayName
                    GrantControls             = ($cap.enforcedGrantControls -join ',')
                    Result                    = $cap.result
                    ConditionsNotSatisfied    = if ($cap.PSObject.Properties.Name -contains 'conditionsNotSatisfied') { ($cap.conditionsNotSatisfied -join ',') } else { $null }
                }
            }
        }
    }

    $hits | Sort-Object When
}

try {
    # 1) Verbinden
    Connect-GraphSafe

    # 2) Modus + Zeitfenster
    $mode = Prompt-Mode
    $daysBack = Prompt-DaysBack
    $sinceUtc = (Get-Date).ToUniversalTime().AddDays(-[double]$daysBack)

    # 3) Policies laden nach Modus
    switch ($mode) {
        'ReportOnly' {
            $policies = Get-PoliciesByState -stateValue 'enabledForReportingButNotEnforced'
        }
        'Active' {
            $policies = Get-PoliciesByState -stateValue 'enabled'
        }
    }

    $selected = Prompt-SelectPolicies -policies $policies
    if ($selected.Count -eq 0) { return }
    $selectedNames = $selected.DisplayName

    # 4) Logs auswerten
    switch ($mode) {
        'ReportOnly' {
            $results = Get-ReportOnlyBlockedSignIns -sinceUtc $sinceUtc -policyNames $selectedNames
        }
        'Active' {
            $results = Get-ActiveBlockedSignIns -sinceUtc $sinceUtc -policyNames $selectedNames
        }
    }

    Write-Host ""
    Write-Host "=================== AUSWERTUNG ===================" -ForegroundColor Green
    Write-Host ("Modus: {0}" -f ($mode -eq 'ReportOnly' ? 'Report-Only (würde blockieren)' : 'Aktiv (tatsächlich geblockt)'))
    Write-Host ("Zeitraum: Letzte {0} Tag(e) (ab {1} UTC)" -f $daysBack, $sinceUtc.ToString('u'))
    Write-Host ("Policies: {0}" -f ($selectedNames -join ', '))

    if (-not $results -or $results.Count -eq 0) {
        Write-Host "Keine Anmeldeversuche entsprechend der Kriterien gefunden." -ForegroundColor Yellow
        return
    }

    $total = $results.Count
    Write-Host ("Gefundene Anmeldungen: {0}" -f $total) -ForegroundColor Cyan

    # Kleine Statistik
    $byUser = $results | Group-Object User | Sort-Object Count -Descending
    $byIP   = $results | Group-Object IP   | Sort-Object Count -Descending

    Write-Host "`nTop 10 Benutzer:" -ForegroundColor Cyan
    $byUser | Select-Object -First 10 | ForEach-Object {
        "{0,4}  {1}" -f $_.Count, $_.Name
    } | Write-Host

    Write-Host "`nTop 10 IPs:" -ForegroundColor Cyan
    $byIP | Select-Object -First 10 | ForEach-Object {
        "{0,4}  {1}" -f $_.Count, $_.Name
    } | Write-Host

    Write-Host "`nDetails (letzte 50):" -ForegroundColor Cyan
    $results | Select-Object -Last 50 | Format-Table Mode, When, User, IP, App, Policy, GrantControls, Result -AutoSize

    # Optionaler CSV-Export
    $export = Read-Host "`nCSV exportieren? (y/N)"
    if ($export -match '^(?i)y(es)?$') {
        $path = Join-Path -Path (Get-Location) -ChildPath ("CA-Blocks_{0}_{1:yyyyMMdd_HHmmss}.csv" -f $mode, (Get-Date))
        $results | Export-Csv -Path $path -NoTypeInformation -Encoding UTF8
        Write-Host "CSV exportiert: $path" -ForegroundColor Green
    }

} catch {
    Write-Host "Fehler: $($_.Exception.Message)" -ForegroundColor Red
} finally {
    try { Disconnect-MgGraph | Out-Null } catch { }
}
